import { Expense } from "@/types/expense";
import { filterByMonth } from "@/utils/dateUtils";
import { convertApiExpenseToExpense } from "@/utils/expenseUtils";
import {
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from "react";
import { useApi } from "../hooks/useApi";

interface IncomeData {
  id: number;
  tipo: "recorrente" | "pontual";
  descricao: string;
  amount: number;
  categoria: "salario" | "freelance" | "investimento" | "bonus" | "outros";
}

interface MonthlyDataState {
  expenses: Expense[];
  incomes: IncomeData[];
  loading: boolean;
  error: string | null;
}

interface MonthlyDataContextType {
  data: Record<string, MonthlyDataState>;
  loadMonthData: (month: number, year: number) => Promise<void>;
  getMonthData: (month: number, year: number) => MonthlyDataState;
  invalidateCurrentMonth: () => void;
}

const MonthlyDataContext = createContext<MonthlyDataContextType | undefined>(
  undefined
);

interface MonthlyDataProviderProps {
  children: ReactNode;
}

export function MonthlyDataProvider({ children }: MonthlyDataProviderProps) {
  const { getExpenses, getIncomes } = useApi();
  const [data, setData] = useState<Record<string, MonthlyDataState>>({});
  const [loadingStates, setLoadingStates] = useState<Set<string>>(new Set());

  // Usar refs para acessar valores atuais sem depend√™ncias
  const dataRef = useRef(data);
  const loadingStatesRef = useRef(loadingStates);
  const requestQueueRef = useRef<Set<string>>(new Set()); // Controlar requisi√ß√µes em andamento globalmente

  // Atualizar refs quando estados mudam
  useEffect(() => {
    dataRef.current = data;
  }, [data]);

  useEffect(() => {
    loadingStatesRef.current = loadingStates;
  }, [loadingStates]);

  // Fun√ß√£o para invalidar dados de um m√™s espec√≠fico
  const invalidateMonth = useCallback((month: number, year: number) => {
    const key = `${year}-${month}`;
    console.log(`üîÑ Invalidando dados para ${month + 1}/${year}`);

    setData((prev) => {
      const newData = { ...prev };
      delete newData[key];
      return newData;
    });

    // Recarregar dados
    loadMonthData(month, year);
  }, []);

  const getMonthData = useCallback(
    (month: number, year: number): MonthlyDataState => {
      const key = `${year}-${month}`;
      return (
        data[key] || {
          expenses: [],
          incomes: [],
          loading: true,
          error: null,
        }
      );
    },
    [data]
  );

  const loadExpenses = async (
    month: number,
    year: number
  ): Promise<Expense[]> => {
    try {
      // Tentar carregar despesas com filtro primeiro
      const apiExpenses = await getExpenses({
        month: month,
        year: year,
      });

      if (Array.isArray(apiExpenses)) {
        return apiExpenses.map(convertApiExpenseToExpense);
      } else {
        // Fallback: buscar todas e filtrar localmente
        const allExpenses = await getExpenses();
        if (Array.isArray(allExpenses)) {
          const convertedExpenses = allExpenses.map(convertApiExpenseToExpense);
          return filterByMonth(convertedExpenses, month, year);
        }
        return [];
      }
    } catch (error) {
      console.error("Erro ao carregar despesas:", error);
      return [];
    }
  };

  const loadIncomes = async (
    month: number,
    year: number
  ): Promise<IncomeData[]> => {
    try {
      // Tentar carregar receitas com filtro primeiro
      const apiIncomes = await getIncomes({
        month: month,
        year: year,
      });

      if (Array.isArray(apiIncomes)) {
        return apiIncomes;
      } else {
        // Fallback: buscar todas e filtrar localmente
        const allIncomes = await getIncomes();
        if (Array.isArray(allIncomes)) {
          return filterByMonth(allIncomes, month, year);
        }
        return [];
      }
    } catch (error) {
      console.error("Erro ao carregar receitas:", error);
      return [];
    }
  };

  const refreshMonthData = useCallback(async (month: number, year: number) => {
    const key = `${year}-${month}`;

    console.log(`üîÑ Fazendo refresh em background para ${month + 1}/${year}`);

    try {
      // Fazer requisi√ß√µes em paralelo
      const [expenses, incomes] = await Promise.all([
        loadExpenses(month, year),
        loadIncomes(month, year),
      ]);

      setData((prev) => ({
        ...prev,
        [key]: {
          expenses,
          incomes,
          loading: false,
          error: null,
        },
      }));

      console.log(`‚úÖ Refresh conclu√≠do para ${month + 1}/${year}`, {
        expenses: expenses.length,
        incomes: incomes.length,
      });
    } catch (error) {
      console.error(`‚ùå Erro no refresh para ${month + 1}/${year}:`, error);
    }
  }, []);

  const loadMonthData = useCallback(
    async (month: number, year: number) => {
      const key = `${year}-${month}`;

      console.log(`üîç Verificando dados para ${month + 1}/${year}`, {
        hasData: !!dataRef.current[key],
        isLoading: loadingStatesRef.current.has(key),
        inQueue: requestQueueRef.current.has(key),
        currentData: dataRef.current[key],
      });

      // CONTROLE TRIPLO: Se j√° est√° carregando OU na fila de requisi√ß√µes, n√£o iniciar nova requisi√ß√£o
      if (
        loadingStatesRef.current.has(key) ||
        requestQueueRef.current.has(key)
      ) {
        console.log(
          `‚è≥ J√° processando dados para ${
            month + 1
          }/${year} (loading: ${loadingStatesRef.current.has(
            key
          )}, queued: ${requestQueueRef.current.has(key)})`
        );
        return;
      }

      // Se j√° temos dados v√°lidos para este m√™s, n√£o recarregar
      if (
        dataRef.current[key] &&
        !dataRef.current[key].loading &&
        !dataRef.current[key].error
      ) {
        console.log(`‚úÖ Dados j√° existem para ${month + 1}/${year}`);
        return;
      }

      console.log(`üîÑ Iniciando carregamento para ${month + 1}/${year}`);

      // Adicionar √† fila de requisi√ß√µes ANTES de tudo
      requestQueueRef.current.add(key);

      setLoadingStates((prev) => new Set(prev).add(key));

      // Marcar como carregando
      setData((prev) => ({
        ...prev,
        [key]: {
          expenses: [],
          incomes: [],
          loading: true,
          error: null,
        },
      }));

      try {
        // Fazer requisi√ß√µes em paralelo
        const [expenses, incomes] = await Promise.all([
          loadExpenses(month, year),
          loadIncomes(month, year),
        ]);

        setData((prev) => ({
          ...prev,
          [key]: {
            expenses,
            incomes,
            loading: false,
            error: null,
          },
        }));

        console.log(`‚úÖ Dados carregados para ${month + 1}/${year}`, {
          expenses: expenses.length,
          incomes: incomes.length,
        });
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Erro ao carregar dados";
        setData((prev) => ({
          ...prev,
          [key]: {
            expenses: [],
            incomes: [],
            loading: false,
            error: errorMessage,
          },
        }));
        console.error(
          `‚ùå Erro ao carregar dados para ${month + 1}/${year}:`,
          error
        );
      } finally {
        // Remover da fila de requisi√ß√µes E do loading states
        requestQueueRef.current.delete(key);
        setLoadingStates((prev) => {
          const newSet = new Set(prev);
          newSet.delete(key);
          return newSet;
        });
      }
    },
    [] // Removendo depend√™ncias para evitar recria√ß√£o
  );

  const invalidateCurrentMonth = useCallback(() => {
    const now = new Date();
    const currentKey = `${now.getFullYear()}-${now.getMonth()}`;

    setData((prev) => {
      const newData = { ...prev };
      delete newData[currentKey];
      return newData;
    });

    // Recarregar dados do m√™s atual
    loadMonthData(now.getMonth(), now.getFullYear());
  }, [loadMonthData]);

  // Carregar dados do m√™s atual na inicializa√ß√£o (apenas uma vez)
  useEffect(() => {
    const now = new Date();
    const currentKey = `${now.getFullYear()}-${now.getMonth()}`;

    // S√≥ carregar se ainda n√£o temos dados para o m√™s atual
    if (!data[currentKey]) {
      console.log("üöÄ Inicializando dados do m√™s atual");
      loadMonthData(now.getMonth(), now.getFullYear());
    }
  }, []); // Array vazio para executar apenas na montagem

  // Escutar eventos de novos dados para atualizar o m√™s correto
  useEffect(() => {
    const handleExpenseAdded = (e: Event) => {
      const customEvent = e as CustomEvent;
      const expense = customEvent.detail;
      if (!expense || !expense.data) return;

      const expenseDate = new Date(expense.data);
      const month = expenseDate.getMonth();
      const year = expenseDate.getFullYear();
      const key = `${year}-${month}`;

      console.log(`üí∞ Expense adicionado, atualizando ${month + 1}/${year}`);

      // Ao inv√©s de deletar os dados, adicionar o novo expense localmente
      setData((prev) => {
        const currentData = prev[key];
        if (!currentData) {
          // Se n√£o h√° dados para este m√™s, n√£o fazer nada (os componentes carregar√£o quando necess√°rio)
          return prev;
        }

        // Verificar se o expense est√° no formato correto
        const formattedExpense = {
          id: expense.id,
          descricao: expense.descricao,
          categoria: expense.categoria,
          valor: Number(expense.valor),
          data: expense.data,
          tipo: expense.tipo || "unico",
        };

        // Adicionar o novo expense aos dados existentes
        return {
          ...prev,
          [key]: {
            ...currentData,
            expenses: [...currentData.expenses, formattedExpense],
          },
        };
      });
    };

    const handleExpenseDeleted = (e: Event) => {
      const customEvent = e as CustomEvent;
      const { id, month, year } = customEvent.detail;
      if (!id) return;

      const key = `${year}-${month}`;
      console.log(
        `üóëÔ∏è Expense deletado, removendo ${id} de ${month + 1}/${year}`
      );

      setData((prev) => {
        const currentData = prev[key];
        if (!currentData) return prev;

        return {
          ...prev,
          [key]: {
            ...currentData,
            expenses: currentData.expenses.filter(
              (expense) => expense.id !== id
            ),
          },
        };
      });
    };

    const handleIncomeAdded = (e: Event) => {
      const customEvent = e as CustomEvent;
      const income = customEvent.detail;
      if (!income || !income.dataRecebimento) return;

      const incomeDate = new Date(income.dataRecebimento);
      const month = incomeDate.getMonth();
      const year = incomeDate.getFullYear();
      const key = `${year}-${month}`;

      console.log(`üíµ Income adicionado, atualizando ${month + 1}/${year}`);

      // Converter income para o formato esperado pelo contexto
      const contextIncome: IncomeData = {
        id: parseInt(income.id),
        tipo: income.tipo || "pontual",
        descricao: income.descricao,
        amount: Number(income.valor || income.amount),
        categoria: income.categoria,
      };

      // Adicionar o novo income aos dados existentes
      setData((prev) => {
        const currentData = prev[key];
        if (!currentData) {
          // Se n√£o h√° dados para este m√™s, n√£o fazer nada (os componentes carregar√£o quando necess√°rio)
          return prev;
        }

        return {
          ...prev,
          [key]: {
            ...currentData,
            incomes: [...currentData.incomes, contextIncome],
          },
        };
      });
    };

    const handleIncomeDeleted = (e: Event) => {
      const customEvent = e as CustomEvent;
      const { id, month, year } = customEvent.detail;
      if (!id) return;

      const key = `${year}-${month}`;
      console.log(
        `üóëÔ∏è Income deletado, removendo ${id} de ${month + 1}/${year}`
      );

      setData((prev) => {
        const currentData = prev[key];
        if (!currentData) return prev;

        return {
          ...prev,
          [key]: {
            ...currentData,
            incomes: currentData.incomes.filter((income) => income.id !== id),
          },
        };
      });
    };

    window.addEventListener("expenseAdded", handleExpenseAdded);
    window.addEventListener("expenseDeleted", handleExpenseDeleted);
    window.addEventListener("incomeAdded", handleIncomeAdded);
    window.addEventListener("incomeDeleted", handleIncomeDeleted);

    return () => {
      window.removeEventListener("expenseAdded", handleExpenseAdded);
      window.removeEventListener("expenseDeleted", handleExpenseDeleted);
      window.removeEventListener("incomeAdded", handleIncomeAdded);
      window.removeEventListener("incomeDeleted", handleIncomeDeleted);
    };
  }, [loadMonthData, refreshMonthData]);

  const value: MonthlyDataContextType = {
    data,
    loadMonthData,
    getMonthData,
    invalidateCurrentMonth,
  };

  return (
    <MonthlyDataContext.Provider value={value}>
      {children}
    </MonthlyDataContext.Provider>
  );
}

export function useMonthlyData(month?: number, year?: number) {
  const context = useContext(MonthlyDataContext);
  if (context === undefined) {
    throw new Error("useMonthlyData must be used within a MonthlyDataProvider");
  }

  // Se n√£o especificar m√™s/ano, usar o m√™s atual
  const now = new Date();
  const targetMonth = month ?? now.getMonth();
  const targetYear = year ?? now.getFullYear();
  const key = `${targetYear}-${targetMonth}`;

  const monthData = context.getMonthData(targetMonth, targetYear);

  // Carregar dados apenas uma vez por key - o contexto agora controla duplica√ß√µes
  useEffect(() => {
    const currentData = context.data[key];

    console.log(
      `üéØ Hook ${Math.random().toString(36).substr(2, 5)} verificando ${
        targetMonth + 1
      }/${targetYear}`,
      {
        hasData: !!currentData,
        data: currentData,
      }
    );

    // S√≥ fazer requisi√ß√£o se realmente n√£o temos dados v√°lidos
    if (
      !currentData ||
      (currentData.loading &&
        currentData.expenses.length === 0 &&
        currentData.incomes.length === 0 &&
        !currentData.error)
    ) {
      // Verificar se j√° n√£o est√° sendo processado antes de solicitar
      if (!context.data[key]?.loading) {
        console.log(
          `üìû Hook solicitando carregamento de ${targetMonth + 1}/${targetYear}`
        );
        context.loadMonthData(targetMonth, targetYear);
      }
    } else {
      console.log(`‚úÖ Hook j√° tem dados para ${targetMonth + 1}/${targetYear}`);
    }
  }, [key, context.loadMonthData]); // Mantendo apenas depend√™ncias essenciais

  return {
    ...monthData,
    refresh: () => context.loadMonthData(targetMonth, targetYear),
    invalidateCurrentMonth: context.invalidateCurrentMonth,
  };
}
